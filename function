def solve(board):
        
    from copy import deepcopy
    

    def col(p):                 # columns
        return [list(i) for i in zip(*p)]
    
    
    def triplet(p):             # 3x3 blocks
        triplet_ = []
        for k in range(3):
            tr3 = []
            for i in range(3):
                tr1 = [p[j+k*3][i*3:i*3+3] for j in range(3)]
                tr1 = [tr1[i][j] for i in range(3) for j in range(3)]
                tr3.append(tr1)
            triplet_.extend(tr3)
        return triplet_
    
    
    def check(p):               # check solution
        for x in p:
            if set([1,2,3,4,5,6,7,8,9]).difference(x):
                return False
        for x in col(p):
            if set([1,2,3,4,5,6,7,8,9]).difference(x):
                return False
        for x in triplet(p):
            if set([1,2,3,4,5,6,7,8,9]).difference(x):
                return False
        return True
    
    
    def basic(puzzle, stack):              # Basic algorithm. Searching available numbers for each cell. If only one variant - update puzzle.                               
        new_data = True                    # if new puzzle after updating
        got_zeros = True                   # empty cells
        new_puzzle = deepcopy(puzzle)

        while got_zeros and new_data:
            puzzle = deepcopy(new_puzzle)
            got_zeros = False
            new_data = False
            min_ = False            # (empty cell with minimum variants to fill)
            columns = col(puzzle)
            triplets = triplet(puzzle)
            
            for i in range(9):
                for j in range(9):
                    if puzzle[i][j] == 0:           # empty cell
                        got_zeros = True
                        x = set([1,2,3,4,5,6,7,8,9])            # all available variants to fill
                        x.difference_update(puzzle[i])                  # exclude all in row
                        x.difference_update(columns[j])                 # exclude all in column
                        x.difference_update(triplets[(i//3)*3 + j//3])  # exclude all in 3x3 block
                        if len(x)==0:                           # wrong solution, try next 
                            return False, new_puzzle
                        if len(x)==1:                                   # if only one variant for cell - it's proper 
                            new_puzzle[i][j] = list(x)[0]
                            new_data = True
                        else:                                           # we must choose any varyant to fill any cell
                            if min_:                                    # let's find cell with least amount of variants 
                                if len(x) < min_[0]:
                                    min_ = (len(x), [i,j], list(x))
                            else:
                                min_ = (len(x), [i,j], list(x))

        if not(got_zeros):
            return (check(new_puzzle), new_puzzle)   
        else:                                           # add variants to stack
            for i in range(min_[0]):
                a = min_[1][0]
                b = min_[1][1]
                new_puzzle[a][b] = min_[2][i]
                stack.append(deepcopy(new_puzzle))
            return (False, new_puzzle)

        
    def sudoku_solver(puzzle, stack):
        done, puzzle = basic(puzzle, stack)             # try to fill empy cells while possible, thereafter for cell with minimum N variants create N versions of puzzle and put them to stack
        while not(done):
            puzzle = stack.pop()                        # get version of puzzle
            done, puzzle = basic(puzzle, stack)         # try to fill empy cells while possible, thereafter for cell with minimum N variants create N versions of puzzle and put them to stack
        return puzzle
    
    
    stack = []
    return sudoku_solver(board, stack)
